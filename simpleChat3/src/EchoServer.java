// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.sql.SQLOutput;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.*;import common.ChatIF;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer{  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;  private ChatIF serverConsole;  private ObservableOriginatorServer os;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF servCons)  {    this.serverConsole = servCons;    this.os = new ObservableOriginatorServer(port);    os.addObserver(this);    try {      os.listen();    } catch (IOException e) {      System.out.println("The server cannot switch to listen mode. The program will stop.");      System.exit(0);    }  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient(Object msg, ConnectionToClient client)  {    if(!msg.toString().startsWith("#login") && client.getInfo("pseudo")==null){ // Test première connexion      try {        client.sendToClient("ERREUR VOUS DEVEZ RENTRER VOTRE LOGIN avec la commande #login [nom d'utilisateur]");      } catch (IOException e) {        throw new RuntimeException(e);      }    } else {      if (msg.toString().startsWith("#login")) { // login        if(client.getInfo("pseudo")==null){          String pseudo = toPseudo(msg.toString());          client.setInfo("pseudo", pseudo);          client.setInfo("logged", true);          serverConsole.display("Login de "+client.getInfo("pseudo"));        } else {          try {            client.sendToClient("Vous êtes déjà connecté.");          } catch (IOException e) {            throw new RuntimeException(e);          }        }      } else if (msg.equals("#logoff") || msg.equals("#quit")){ // logoff        try{          client.close();          serverConsole.display("Message received: " + msg + " from " + client.getInfo("pseudo"));        } catch (IOException e) {          serverConsole.display("ERROR - Logoff Client "+client.toString());        }      } else { // message        serverConsole.display("Message received: " + msg + " from " + client.getInfo("pseudo"));        String mess = client.getInfo("pseudo").toString()+ " > " + msg.toString();        os.sendToAllClients(mess);      }    }  }  public String toPseudo(String message){    String pseudo = "";    String[] tab = message.split(" ");    if(tab.length==2) {      pseudo = tab[1];    } else if(tab.length>2) {      for (int i = 1; i < tab.length; i++) {        pseudo += tab[i] + "_";      }      pseudo = pseudo.substring(0, pseudo.length()-1);    } else {      // Pseudo random    }    return pseudo;  }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    System.out.println      ("Server listening for connections on port " + os.getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    System.out.println      ("Server has stopped listening for connections.");  }  /**   * Hook method called each time a client disconnects.   * The default implementation does nothing. The method   * may be overridden by subclasses but should remains synchronized.   *   * @param client the connection with the client.   */  synchronized protected void clientDisconnected(ConnectionToClient client) {    System.out.println("Un client s'est déconnecté. Client : " + client.getInfo("pseudo"));    os.sendToAllClients("Votre ami : " + client.getInfo("pseudo") + " est parti :(");  }  private void clientException(ConnectionToClient client, Throwable e) {    System.out.println("La connexion avec " + client.getInfo("id") + " a été perdue");  }  /**   * This method handles all data coming from the UI   *   * @param message The message from the UI.   */  public void handleMessageFromServerUI(String message)  {    int co = 1;    if(message.charAt(0)=='#'){      co = commands(message);    } if(co==1) {      serverConsole.display("Message envoyé : "+message);      os.sendToAllClients("Server MSG > "+message);    }  }  protected int commands(String command){    int co = 0;    if(command.equals("#quit")){ // arrête l'exécution du serveur      try {        os.close();        System.exit(0);      } catch (IOException e) {        throw new RuntimeException(e);      }    } else if (command.equals("#stop")){ // termine l'écoute des nouvelles connexions      os.stopListening();    } else if (command.equals("#close")){ // termine l'écoute des nouvelles connexions et déconnecte tous les clients      os.stopListening();      try {        os.close();      } catch (IOException e) {        throw new RuntimeException(e);      }    } else if (command.startsWith("#setport ")){ // change le port du server      if(!os.isListening()){        String[] tab = command.split(" ");        os.setPort(Integer.parseInt(tab[1]));        System.out.println("Successfully changed the port by :"+os.getPort());      }    } else if (command.equals("#getport")){ // renvoi le port du server      System.out.println("The port :"+os.getPort());    } else if (command.equals("#start")){ // lance le serveur en état d'écoute de connexions      if(!os.isListening()){        try {          os.listen();        } catch (IOException e) {          throw new RuntimeException(e);        }      }    } else if (command.equals("#getmyIntership")){      System.out.println("Thanks you soooooooooo much !!! <3 <3 ");    }    else {      co = 1;    }    return co;  }  //Class methods ***************************************************    /**   * This method is responsible for the creation of    * the server instance (there is no UI in this phase).   *   * @param args[0] The port number to listen on.  Defaults to 5555    *          if no argument is entered.   */  public static void main(String[] args)   {  }  @Override  public void update(Observable o, Object arg) {    OriginatorMessage X = (OriginatorMessage) arg;    String mes = X.getMessage().toString();    if(X.getMessage().equals(os.CLIENT_CONNECTED)){      System.out.println("Un nouveau client s'est connecté.");    } else if (mes.equals(os.CLIENT_DISCONNECTED)){      clientDisconnected(X.getOriginator());    } else if (mes.startsWith(os.CLIENT_EXCEPTION)){      clientException(X.getOriginator(),new Throwable("ERREUR CLIENT EXCEPTION"));    } else if (mes.startsWith(os.LISTENING_EXCEPTION)){      System.out.println("ERREUR LISTENING EXCEPTION");    } else if (mes.equals(os.SERVER_CLOSED)){      System.out.println("Le serveur va se fermer");    } else if (mes.equals(os.SERVER_STARTED)){      serverStarted();    } else if (mes.equals(os.SERVER_STOPPED)){      serverStopped();    } else {      handleMessageFromClient(X.getMessage(), X.getOriginator());    }  }}//End of EchoServer class